{"ast":null,"code":"import { ArrayDataSource, isDataSource } from \"@angular/cdk/collections\";\nimport { CdkHeaderRowDef, STICKY_POSITIONING_LISTENER, _COALESCED_STYLE_SCHEDULER } from \"@angular/cdk/table\";\nimport { isObservable, of, Subject } from \"rxjs\";\nimport { map, pairwise, shareReplay, startWith, switchMap, takeUntil } from \"rxjs/operators\";\nimport { TableVirtualScrollViewportComponent } from \"../table-virtual-scroll-viewport/table-virtual-scroll-viewport.component\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/cdk/scrolling\";\nimport * as i2 from \"@angular/cdk/table\";\n/**\n * Directive that wraps a given data source in a \"virtual\" data source that emits\n * the slice of the original data source that matches the range that should be rendered\n * in the containing virtual scroll viewport.\n */\nexport let VirtualTableDirective = /*#__PURE__*/(() => {\n  class VirtualTableDirective {\n    set dataSource(value) {\n      this._dataSource = value;\n      if (isDataSource(value)) {\n        this.dataSourceChanges.next(value);\n      } else {\n        this.dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\n      }\n    }\n    get dataSource() {\n      return this._dataSource;\n    }\n    constructor(elementRef, viewport, table, ngZone, _coalescedStyleScheduler) {\n      this.viewport = viewport;\n      this.table = table;\n      this._coalescedStyleScheduler = _coalescedStyleScheduler;\n      this.virtualizedDataStream = new Subject();\n      this.dataSourceChanges = new Subject();\n      /** The raw, unvirtualized data stream. Emits whenever the data in the current DataSource changes. */\n      this.dataStream = this.dataSourceChanges.pipe(\n      // Start off with null data source.\n      startWith(null),\n      // Bundle up the previous and current data sources so we can work with both.\n      pairwise(),\n      // Use `changeDataSource` to disconnect from the previous data source and connect to the\n      // new one, passing back a stream of data changes which we run through `switchMap` to give\n      // us a data stream that emits the latest data from whatever the current data source is.\n      switchMap(([prev, cur]) => this.changeDataSource(prev, cur)),\n      // Replay the last emitted data when someone subscribes.\n      shareReplay(1));\n      this.viewChange = new Subject();\n      this.destroyed$ = new Subject();\n      this.renderedRange = {\n        start: 0,\n        end: 0\n      };\n      this.isNativeHtmlTable = false;\n      table.dataSource = this.virtualizedDataStream;\n      this.isNativeHtmlTable = elementRef.nativeElement.tagName === 'TABLE';\n      this.dataStream.subscribe(data => {\n        this.data = data;\n        this.onRenderedDataChange();\n      });\n      viewport.renderedRangeStream.pipe(takeUntil(this.destroyed$)).subscribe(range => {\n        this.renderedRange = range;\n        ngZone.run(() => this.viewChange.next(range));\n        this.onRenderedDataChange();\n      });\n      viewport.attach(this);\n    }\n    ngOnInit() {\n      // This is just a proof of concept, but the TableVirtualScrollViewportComponent uses `position: absolute` and `top: #px` instead of `transform: translateY(#px)` to position the viewport.\n      // This removes the need to account for the translation in the `top` of the sticky header rows.\n      if (this.viewport instanceof TableVirtualScrollViewportComponent) {\n        return;\n      }\n      this.viewport.scrolledIndexChange.pipe(map(() => this.viewport.getOffsetToRenderedContentStart()), takeUntil(this.destroyed$)).subscribe(offset => {\n        // We need to set the `style.top` property of the sticky header rows\n        // to the negative value of the virtual scroll viewport's offset, so\n        // make the offset negative.\n        offset = -offset;\n        const stickyStates = this.headerRowDefs.map(rowDef => rowDef.sticky);\n        // This logic is exactly the same as what's in the StickyStyler (literally copy + paste).\n        // The only difference is that the `stickyOffset` variable starts at the virtual scroll\n        // viewport container's offset instead of starting at zero.\n        const rows = this.table._getRenderedRows(this.table._headerRowOutlet);\n        const stickyOffsets = [];\n        const stickyCellHeights = [];\n        const elementsToStick = [];\n        for (let rowIndex = 0, stickyOffset = offset; rowIndex < rows.length; rowIndex++) {\n          stickyOffsets[rowIndex] = stickyOffset;\n          if (!stickyStates[rowIndex]) {\n            continue;\n          }\n          const row = rows[rowIndex];\n          elementsToStick[rowIndex] = this.isNativeHtmlTable ? Array.from(row.children) : [row];\n          const height = row.getBoundingClientRect().height;\n          stickyOffset += height;\n          stickyCellHeights[rowIndex] = height;\n        }\n        // Using the CoalescedStyleScheduler here is optional. It'll work without it,\n        // and CoalescedStyleScheduler is not public (yet?), so feel free to remove it.\n        this._coalescedStyleScheduler.schedule(() => {\n          for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n            if (!stickyStates[rowIndex]) {\n              continue;\n            }\n            for (const element of elementsToStick[rowIndex]) {\n              element.style.top = `${stickyOffsets[rowIndex]}px`;\n            }\n          }\n        });\n      });\n    }\n    ngOnDestroy() {\n      this.destroyed$.next();\n      this.dataSourceChanges.complete();\n      this.virtualizedDataStream.complete();\n    }\n    /** React to scroll state changes in the viewport. */\n    onRenderedDataChange() {\n      if (!this.renderedRange) {\n        return;\n      }\n      this.renderedItems = this.data.slice(this.renderedRange.start, this.renderedRange.end);\n      // delegate rendering to the table by emitting from the virtualizedDataStream\n      this.virtualizedDataStream.next(this.renderedItems);\n    }\n    /** Swap out one data source for another. */\n    changeDataSource(oldDataSource, newDs) {\n      oldDataSource?.disconnect(this);\n      return newDs ? newDs.connect(this) : of();\n    }\n    /**\n     * This method is only used by the experimental AutoSizeVirtualScrollStrategy.\n     * We're not using that strategy, but I've implemented it just to show how it oculd be done.\n     * I'm not actually sure if this works.\n     */\n    measureRangeSize(range, orientation) {\n      if (orientation === 'horizontal' || range.end < range.start) {\n        // virtual scrolling columns are not supported by this directive\n        return 0;\n      }\n      const renderedBodyRows = this.table._getRenderedRows(this.table._rowOutlet);\n      const firstRow = renderedBodyRows[range.start];\n      const lastRow = renderedBodyRows[range.end];\n      if (!firstRow || !lastRow) {\n        return 0;\n      }\n      // We need to include all header and footer rows in the sum, since they're always rendered\n      const renderedHeaderRows = this.table._getRenderedRows(this.table._headerRowOutlet);\n      const renderedFooterRows = this.table._getRenderedRows(this.table._footerRowOutlet);\n      // TODO (performance): Can we just measure the offset of the first and last items and do some math to avoid having to measure each row individually?\n      const headerHeight = renderedHeaderRows.reduce((sum, row) => {\n        return sum += row.getBoundingClientRect().height;\n      }, 0);\n      const footerHeight = renderedFooterRows.reduce((sum, row) => {\n        return sum += row.getBoundingClientRect().height;\n      }, 0);\n      const bodyHeight = lastRow.getBoundingClientRect().bottom - firstRow.getBoundingClientRect().top;\n      return headerHeight + footerHeight + bodyHeight;\n    }\n    static {\n      this.ɵfac = function VirtualTableDirective_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || VirtualTableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.CdkVirtualScrollViewport), i0.ɵɵdirectiveInject(i2.CdkTable), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(_COALESCED_STYLE_SCHEDULER));\n      };\n    }\n    static {\n      this.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n        type: VirtualTableDirective,\n        selectors: [[\"\", \"mat-table\", \"\", \"appVirtualDataSource\", \"\"], [\"mat-table\", \"appVirtualDataSource\", \"\"]],\n        contentQueries: function VirtualTableDirective_ContentQueries(rf, ctx, dirIndex) {\n          if (rf & 1) {\n            i0.ɵɵcontentQuery(dirIndex, CdkHeaderRowDef, 4);\n          }\n          if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerRowDefs = _t);\n          }\n        },\n        inputs: {\n          dataSource: [0, \"appVirtualDataSource\", \"dataSource\"]\n        },\n        features: [i0.ɵɵProvidersFeature([{\n          provide: STICKY_POSITIONING_LISTENER,\n          useExisting: VirtualTableDirective\n        }])]\n      });\n    }\n  }\n  return VirtualTableDirective;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}