{"ast":null,"code":"import { coerceNumberProperty } from \"@angular/cdk/coercion\";\nimport { VIRTUAL_SCROLL_STRATEGY } from \"@angular/cdk/scrolling\";\nimport { forwardRef } from \"@angular/core\";\nimport { MatHeaderRowDef } from \"@angular/material/table\";\nimport { Subject } from \"rxjs\";\nimport { distinctUntilChanged } from \"rxjs/operators\";\nimport * as i0 from \"@angular/core\";\n/**\n * A custom scroll strategy that accepts a static row height, static header height,\n * and a buffer size. The strategy\n */\nexport class FixedRowSizeTableVirtualScrollStrategy {\n  constructor(rowHeight, buffer, headerHeight) {\n    this._scrolledIndexChange = new Subject();\n    this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\n    this.updateRowHeightAndBuffer(rowHeight, buffer, headerHeight);\n  }\n  /**\n   * Attaches this scroll strategy to a viewport.\n   * @param viewport The viewport to attach this strategy to.\n   */\n  attach(viewport) {\n    this.viewport = viewport;\n    this.updateTotalContentSize();\n    this.updateRenderedRange();\n  }\n  /**\n   * Detaches this scroll strategy from the currently attached viewport.\n   */\n  detach() {\n    this._scrolledIndexChange.complete();\n    this.viewport = null;\n  }\n  onContentScrolled() {\n    this.updateRenderedRange();\n  }\n  onDataLengthChanged() {\n    this.updateTotalContentSize();\n    this.updateRenderedRange();\n  }\n  onContentRendered() {\n    // This method is useful for virtual scroll strategies that measure the rendered\n    // content to determine its height. This scroll strategy assumes that rows have\n    // a static height, so there's no need to implement this method.\n  }\n  onRenderedOffsetChanged() {\n    // Similar to onContentRendered, this method is useful for virtual scroll strategies\n    // that need to track the offset as it changes. This scroll strategy is always able\n    // to calculate the correct offset from other values, so there's no need to implement\n    // this method.\n  }\n  scrollToIndex(index, behavior) {\n    this.viewport?.scrollToOffset(index * this.rowHeight, behavior);\n  }\n  /**\n   * Update the item size and buffer size.\n   * @param rowHeight The height of a row in the virtually scrolling table.\n   * @param buffer The number of rows to buffer outside the viewport.\n   * @param headerHeight The total height of the table header, including all header rows.\n   */\n  updateRowHeightAndBuffer(rowHeight, buffer, headerHeight) {\n    this.rowHeight = rowHeight;\n    this.buffer = buffer;\n    this.headerHeight = headerHeight;\n    this.updateTotalContentSize();\n    this.updateRenderedRange();\n  }\n  updateRenderedRange() {\n    if (!this.viewport) {\n      return;\n    }\n    const viewportSize = this.viewport.getViewportSize();\n    const dataLength = this.viewport.getDataLength();\n    const scrollOffset = this.viewport.measureScrollOffset();\n    // the index of the first item that would be at least partially visible in the viewport\n    let firstVisibleIndex = Math.floor((scrollOffset + this.headerHeight) / this.rowHeight);\n    // if the buffer size is 10 but the first visible item is at, say, index 7\n    // then the buffered items must be 7, because we don't have 10 items available to buffer.\n    const bufferedItems = Math.min(this.buffer, firstVisibleIndex);\n    const itemsInViewport = Math.ceil(viewportSize / this.rowHeight);\n    const itemsToRender = itemsInViewport + this.buffer;\n    // Clamp the new range between 0 and dataLength\n    const newStart = Math.max(0, firstVisibleIndex - bufferedItems);\n    const newEnd = Math.min(dataLength - 1, firstVisibleIndex + itemsToRender);\n    const newRange = {\n      start: newStart,\n      end: newEnd\n    };\n    const newOffset = this.rowHeight * (firstVisibleIndex - bufferedItems);\n    this.viewport.setRenderedContentOffset(newOffset);\n    this.viewport.setRenderedRange(newRange);\n    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n  }\n  updateTotalContentSize() {\n    this.viewport?.setTotalContentSize(this.viewport.getDataLength() * this.rowHeight);\n  }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nexport function fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n  return fixedSizeDir.scrollStrategy;\n}\nexport let FixedRowSizeTableVirtualScrollStrategyDirective = /*#__PURE__*/(() => {\n  class FixedRowSizeTableVirtualScrollStrategyDirective {\n    constructor() {\n      this._rowHeight = 48;\n      this._headerRowHeight = 48;\n      this._buffer = 20;\n      this._headerRows = null;\n      this.headerRowCount = 1;\n      /** The scroll strategy used by this directive. */\n      this.scrollStrategy = new FixedRowSizeTableVirtualScrollStrategy(this.rowHeight, this.buffer, this.headerRowHeight * this.headerRowCount);\n    }\n    /** The height of rows in the table (in pixels). Defaults to 48. */\n    set rowHeight(value) {\n      this._rowHeight = coerceNumberProperty(value);\n    }\n    get rowHeight() {\n      return this._rowHeight;\n    }\n    /**\n     * The height of header rows in the table (in pixels). Defaults to 48.\n     */\n    set headerRowHeight(value) {\n      this._headerRowHeight = coerceNumberProperty(value);\n    }\n    get headerRowHeight() {\n      return this._headerRowHeight;\n    }\n    /**\n     * The number of buffered rows rendered beyond the viewport.\n     * If the number of buffered rows dips below this number, more rows will be rendered. Defaults to 20.\n     */\n    set buffer(value) {\n      this._buffer = coerceNumberProperty(value);\n    }\n    get buffer() {\n      return this._buffer;\n    }\n    set headerRows(value) {\n      this._headerRows = coerceNumberProperty(value, undefined);\n    }\n    get headerRows() {\n      return this._headerRows;\n    }\n    ngOnChanges() {\n      if (this.headerRows != undefined || this.headerRowsQuery) {\n        this.handleChange();\n      }\n    }\n    ngAfterContentInit() {\n      this.headerRowsQuery.changes.subscribe(() => {\n        this.handleChange();\n      });\n    }\n    handleChange() {\n      this.scrollStrategy.updateRowHeightAndBuffer(this.rowHeight, this.buffer,\n      // Use the explicit headerRows input value if set.\n      // Otherwise, fall back to the QueryList length.\n      this.headerRowHeight * (this._headerRows ?? this.headerRowsQuery.length));\n    }\n    static {\n      this.ɵfac = function FixedRowSizeTableVirtualScrollStrategyDirective_Factory(__ngFactoryType__) {\n        return new (__ngFactoryType__ || FixedRowSizeTableVirtualScrollStrategyDirective)();\n      };\n    }\n    static {\n      this.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n        type: FixedRowSizeTableVirtualScrollStrategyDirective,\n        selectors: [[\"cdk-virtual-scroll-viewport\", \"rowHeight\", \"\"], [\"app-table-virtual-scroll-viewport\", \"rowHeight\", \"\"]],\n        contentQueries: function FixedRowSizeTableVirtualScrollStrategyDirective_ContentQueries(rf, ctx, dirIndex) {\n          if (rf & 1) {\n            i0.ɵɵcontentQuery(dirIndex, MatHeaderRowDef, 4);\n          }\n          if (rf & 2) {\n            let _t;\n            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.headerRowsQuery = _t);\n          }\n        },\n        inputs: {\n          rowHeight: \"rowHeight\",\n          headerRowHeight: \"headerRowHeight\",\n          buffer: \"buffer\",\n          headerRows: \"headerRows\"\n        },\n        features: [i0.ɵɵProvidersFeature([{\n          provide: VIRTUAL_SCROLL_STRATEGY,\n          useFactory: fixedSizeVirtualScrollStrategyFactory,\n          deps: [forwardRef(() => FixedRowSizeTableVirtualScrollStrategyDirective)]\n        }]), i0.ɵɵNgOnChangesFeature]\n      });\n    }\n  }\n  return FixedRowSizeTableVirtualScrollStrategyDirective;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}